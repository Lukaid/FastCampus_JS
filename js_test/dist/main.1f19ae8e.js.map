{"version":3,"sources":["main.js"],"names":["a","k","b","console","log","c"],"mappings":"AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,IAAIA,CAAC,GAAG;AAAEC,EAAAA,CAAC,EAAC;AAAJ,CAAR;AACA,IAAIC,CAAC,GAAG;AAAED,EAAAA,CAAC,EAAC;AAAJ,CAAR;AACAE,OAAO,CAACC,GAAR,CAAYJ,CAAZ,EAAeE,CAAf,EAAkBF,CAAC,KAAKE,CAAxB,GAA2B;;AAC3BF,CAAC,CAACC,CAAF,GAAM,CAAN;AACAC,CAAC,GAAGF,CAAJ;AACAG,OAAO,CAACC,GAAR,CAAYJ,CAAZ,EAAeE,CAAf,EAAkBF,CAAC,KAAKE,CAAxB;AACAF,CAAC,CAACC,CAAF,GAAM,CAAN;AACAE,OAAO,CAACC,GAAR,CAAYJ,CAAZ,EAAeE,CAAf,EAAkBF,CAAC,KAAKE,CAAxB;AACA,IAAIG,CAAC,GAAGH,CAAR;AACAC,OAAO,CAACC,GAAR,CAAYJ,CAAZ,EAAeE,CAAf,EAAkBG,CAAlB,EAAqBL,CAAC,KAAKK,CAA3B;AACAL,CAAC,CAACC,CAAF,GAAM,CAAN;AACAE,OAAO,CAACC,GAAR,CAAYJ,CAAZ,EAAeE,CAAf,EAAkBG,CAAlB,EAAqBL,CAAC,KAAKK,CAA3B","file":"main.1f19ae8e.js","sourceRoot":"..","sourcesContent":["// JS 데이터\n\n// 데이터는 원래 new와 전역객체로 생성자를 만들어서 생성해야 함\n// 근데 줜나 번거로우니까 자주 쓰는거는 걍 아래처럼 씀, 이걸 리터럴 방식이라고 부름\n\n// string: \"\", '', ``\n// number, boolean, undefined, null\n// Array: []\n// Object: {}\n\n\n// const result = 'hello world!'.indexOf('lukaid')\n// console.log(result)\n\n// const str = '0123'\n\n// console.log('0 1 2 3'.length)\n\n// const str = 'hello world!'\n// const str = '       lukaid@kau.kr '\n\n// console.log(str.indexOf('world') !== -1)\n// console.log(str.slice(6, -1))\n// console.log(str.replace(' world!', ''))\n// console.log(str.match(/.+(?=@)/)[0]) // 배열의 0번 항\n// console.log(str.trim())\n\n\n// const pi = 3.142592\n// console.log(pi)\n\n// const str = pi.toFixed(2)\n// console.log(str)\n// console.log(typeof str)\n\n// const integer = parseInt(str)\n// const float = parseFloat(str)\n// console.log(integer)\n// console.log(float)\n// console.log(typeof integer, typeof float)\n\n// 수학객체는 눈치껏 알아서\n\n// const numbers = [1, 2, 3, 4]\n// const fruits = ['Apple', 'Banana', 'Cherry']\n\n// console.log(numbers[1])\n// console.log(fruits[2])\n\n// console.log([1, 2, 3].length)\n// console.log([].length)\n\n\n// console.log(numbers.find(el => el > 2))\n\n// console.log(numbers.concat(fruits))\n// console.log(numbers.concat(fruits).length)\n\n// const test = numbers.concat(fruits)\n// console.log(test)\n\n// console.log(numbers)\n// console.log(fruits)\n\n// // 이건 array의 forEach 문법으로 외우자, 순서대로 element, index, array가 callback 함수로 드가고 다 필요한건 아님, 매개변수 이름은 내 맘대로 바까도 됨\n// fruits.forEach(function (element, index, array) {\n//     console.log(element, index, array)\n// })\n\n// .map()\n\n// const a = fruits.forEach((fruit, idx) => {\n//     console.log(`${fruit}-${idx}`)\n// })\n// console.log(a)\n\n// // map 은 array를 반환, return이 꼭 필요\n// // const b = fruits.map(function (fruit, idx) {\n// //     return `${fruit}-${idx}`\n// // })\n\n// // 객체 데이터가 드간 배열 반환\n// const b = fruits.map((fruit, idx) => ({\n//     id: idx,\n//     name: fruit\n// }))\n// console.log(b)\n\n// const a = numbers.map(number => number < 3)\n// console.log(a)\n// // filter, true만 출력\n// const b = numbers.filter(number => number < 3)\n// console.log(b)\n\n// const a = fruits.find(fruit => /^B/.test(fruit))\n// console.log(a)\n\n// const b = fruits.findIndex(fruit => /^B/.test(fruit))\n// console.log(b)\n\n// const a = numbers.includes(3)\n// console.log(a)\n\n// const b = fruits.includes('lukaid')\n// console.log(b)\n\n// .push() .unshift() .reverse() .splice()\n// 원본 수정됨!!\n\n// numbers.push(5) // append\n// console.log(numbers)\n\n// numbers.unshift(0) // 앞에 append\n// console.log(numbers)\n\n// numbers.reverse()\n// fruits.reverse()\n// console.log(numbers)\n// console.log(fruits)\n\n// numbers.splice(2, 1) // splice(idx, 지울 개수, 추가할 아이템)\n// console.log(numbers)\n\n// numbers.splice(2, 0, 99)\n// console.log(numbers)\n\n\n// prototype 이 없는 method 는 정적(static) 메소드\n// {}.assign() 이렇게 사용 불가\n\n// const userAge = {\n//     // key: value\n//     name: 'Lukaid',\n//     age: 29\n// }\n// const userEmail = {\n//     name: 'Lukaid',\n//     email: 'dltjddn0115@naver.com'\n// }\n\n// userAge.assign() 이렇게 사용 불가, prototype이 아님\n// const target = Object.assign(userAge, userEmail)\n// console.log(target)\n// console.log(userAge)\n// console.log(target === userAge) // userAge를 반환한 것이 target, 두 변수 모두 같은 메모리 주소를 가르킴\n\n// 첫번째 인수에 빈 객체를 넣으면 원본 객체는 유지됨\n// const target = Object.assign({}, userAge, userEmail)\n// console.log(target)\n// console.log(userAge)\n// console.log(target === userAge) // userAge를 반환한 것이 target, 두 변수 모두 같은 메모리 주소를 가르킴\n\n\n\n// const a = { k:123 }\n// const b = { k:123 }\n// console.log(a === b) // 내용이 같아도, 다른 객체임, 메모리 주소가 다름\n\n// const c = '1'\n// const d = '1'\n// console.log(c === d)\n\n\n// const user = {\n//     // key: value\n//     name: 'Lukaid',\n//     age: 29,\n//     email: 'dltjddn0115@naver.com'\n// }\n\n// const keys = Object.keys(user)\n// console.log(keys)\n\n// console.log(user['email'])\n\n// const values = keys.map(key => user[key])\n// console.log(values)\n\n// 구조 분해 할당\n// const { name: lukaid, age, address = 'korea'} = user\n// 객체 데이터에서 내가 원하는 value만 key로 꺼내 묵으면 됨\n\n// console.log(`사용자의 이름은 ${lukaid}입니다.`)\n// console.log(`${lukaid}의 나이는 ${age}세 입니다.`)\n// console.log(`${lukaid}의 이메일 주소는 ${user.email}입니다.`)\n// console.log(address)\n\n// 객체 데이터 뿐 아니라 배열 데이터에도 사용 가능\n// 배열은 순서를 꼭 지켜야 됨\n// const fruits = ['Apple', 'Banana', 'Cherry']\n// const [a, b, c, d] = fruits\n// console.log(a, b, c, d)\n\n// 전개 연산자\n\n// const fruits = ['Apple', 'Banana', 'Cherry', 'Orange']\n// console.log(fruits)\n// console.log(...fruits)\n// console.log('Apple', 'Banana', 'Cherry') 아렇게 전개한 것 처럼 출력\n\n// function toObject(a, b, ...c) {\n//     return {\n//         a: a,\n//         b: b,\n//         c: c\n//     }\n// }\n// 속성의 이름과 변수의 이름이 같으면 하나만 써도 됨\n// const toObject = (a, b, ...c) => ({a, b, ...c})\n\n\n// console.log(toObject(...fruits))\n\n\n\n// 데이터 불변성 (Immuatblility) 한 번 만들어진 메모리는 불변함, 메모리 주소만 재 할당\n// 원시데이터: String, Number, Boolean, undefined, null\n// 참조제이터: Object, Array, Function\n\n// let a = 1\n// let b = 4\n// console.log(a, b, a === b)\n// b = a\n// console.log(a, b, a === b)\n// a = 7\n// console.log(a, b, a === b)\n// let c = 1\n// console.log(b, c, b === c)\n\n// 참조데이터는 생긴게 똑같아도 같이 않을 수 있음\nlet a = { k:1 }\nlet b = { k:1 }\nconsole.log(a, b, a === b) // 생긴게 같아도 다른 주소로 할당 되어서 false\na.k = 7\nb = a\nconsole.log(a, b, a === b)\na.k = 2\nconsole.log(a, b, a === b)\nlet c = b\nconsole.log(a, b, c, a === c)\na.k = 9\nconsole.log(a, b, c, a === c)\n"]}